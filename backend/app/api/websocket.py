"""
WebSocket API routes for DEX Sniper Pro.
Provides clean, unified WebSocket endpoints replacing all existing WebSocket routes.

File: backend/app/api/websocket.py
"""

from __future__ import annotations

import logging
import uuid
from typing import Optional

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query, Path
from fastapi.responses import HTMLResponse

from ..ws.hub import ws_hub, Channel, MessageType, WebSocketMessage


logger = logging.getLogger(__name__)

router = APIRouter(prefix="/ws", tags=["websocket"])


@router.websocket("/{client_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    client_id: str = Path(..., description="Unique client identifier")
):
    """
    Main WebSocket endpoint for DEX Sniper Pro.
    
    Handles all WebSocket connections through a single, clean endpoint.
    Clients can subscribe to different channels after connecting.
    
    Args:
        websocket: WebSocket connection
        client_id: Unique client identifier (generated by frontend)
    """
    logger.info(f"WebSocket connection attempt: {client_id}")
    
    # Connect client to the hub
    connected = await ws_hub.connect_client(client_id, websocket)
    if not connected:
        logger.error(f"Failed to connect WebSocket client: {client_id}")
        return
    
    try:
        # Handle incoming messages from client
        while True:
            data = await websocket.receive_text()
            await ws_hub.handle_client_message(client_id, data)
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket client disconnected normally: {client_id}")
    except Exception as e:
        logger.error(f"WebSocket error for client {client_id}: {e}")
    finally:
        await ws_hub.disconnect_client(client_id, "Connection closed")


@router.get("/status")
async def websocket_status():
    """
    Get WebSocket hub status and connection statistics.
    
    Returns:
        Dict containing hub status, connection count, and channel subscriptions
    """
    return {
        "status": "operational",
        "hub_stats": ws_hub.get_connection_stats(),
        "endpoints": {
            "main": "/ws/{client_id}",
            "description": "Single WebSocket endpoint with channel subscriptions"
        }
    }


@router.get("/test")
async def websocket_test_page():
    """
    Simple test page for WebSocket connections during development.
    
    Returns:
        HTML page with WebSocket test client
    """
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>DEX Sniper Pro - WebSocket Test</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .container { max-width: 800px; margin: 0 auto; }
            .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
            .connected { background-color: #d4edda; color: #155724; }
            .disconnected { background-color: #f8d7da; color: #721c24; }
            .messages { height: 300px; border: 1px solid #ccc; padding: 10px; overflow-y: scroll; }
            button { padding: 8px 16px; margin: 5px; cursor: pointer; }
            input, select { padding: 5px; margin: 5px; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>DEX Sniper Pro - WebSocket Test Client</h1>
            
            <div id="status" class="status disconnected">Disconnected</div>
            
            <div>
                <button onclick="connect()">Connect</button>
                <button onclick="disconnect()">Disconnect</button>
                <button onclick="sendHeartbeat()">Send Heartbeat</button>
            </div>
            
            <div>
                <select id="channel">
                    <option value="autotrade">Autotrade</option>
                    <option value="discovery">Discovery</option>
                    <option value="system">System</option>
                </select>
                <button onclick="subscribe()">Subscribe to Channel</button>
                <button onclick="unsubscribe()">Unsubscribe</button>
            </div>
            
            <div>
                <h3>Messages:</h3>
                <div id="messages" class="messages"></div>
                <button onclick="clearMessages()">Clear Messages</button>
            </div>
        </div>

        <script>
            let ws = null;
            let clientId = 'test_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            function updateStatus(connected) {
                const statusEl = document.getElementById('status');
                if (connected) {
                    statusEl.textContent = `Connected (Client ID: ${clientId})`;
                    statusEl.className = 'status connected';
                } else {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'status disconnected';
                }
            }

            function addMessage(message) {
                const messagesEl = document.getElementById('messages');
                const timestamp = new Date().toLocaleTimeString();
                messagesEl.innerHTML += `<div><strong>[${timestamp}]</strong> ${message}</div>`;
                messagesEl.scrollTop = messagesEl.scrollHeight;
            }

            function connect() {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    addMessage('Already connected');
                    return;
                }

                const wsUrl = `ws://localhost:8000/ws/${clientId}`;
                addMessage(`Connecting to: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);

                ws.onopen = function(event) {
                    updateStatus(true);
                    addMessage('‚úÖ WebSocket connected successfully');
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        addMessage(`üì® Received: ${data.type} on ${data.channel} - ${JSON.stringify(data.data)}`);
                    } catch (e) {
                        addMessage(`üì® Raw message: ${event.data}`);
                    }
                };

                ws.onclose = function(event) {
                    updateStatus(false);
                    addMessage(`‚ùå WebSocket closed: ${event.code} - ${event.reason}`);
                };

                ws.onerror = function(error) {
                    addMessage(`üö® WebSocket error: ${error}`);
                };
            }

            function disconnect() {
                if (ws) {
                    ws.close();
                    ws = null;
                }
            }

            function sendMessage(type, channel, data) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    addMessage('‚ùå Not connected');
                    return;
                }

                const message = {
                    id: Date.now().toString(),
                    type: type,
                    channel: channel,
                    data: data,
                    timestamp: new Date().toISOString(),
                    client_id: clientId
                };

                ws.send(JSON.stringify(message));
                addMessage(`üì§ Sent: ${type} to ${channel}`);
            }

            function sendHeartbeat() {
                sendMessage('heartbeat', 'system', { ping: true });
            }

            function subscribe() {
                const channel = document.getElementById('channel').value;
                sendMessage('subscription_ack', 'system', { 
                    action: 'subscribe', 
                    channel: channel 
                });
            }

            function unsubscribe() {
                const channel = document.getElementById('channel').value;
                sendMessage('subscription_ack', 'system', { 
                    action: 'unsubscribe', 
                    channel: channel 
                });
            }

            function clearMessages() {
                document.getElementById('messages').innerHTML = '';
            }

            // Auto-connect on page load
            window.onload = function() {
                addMessage('WebSocket Test Client loaded');
                addMessage(`Generated Client ID: ${clientId}`);
            };
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)


# Helper functions for broadcasting messages to channels

async def broadcast_autotrade_message(message_type: MessageType, data: dict) -> int:
    """
    Broadcast a message to all autotrade channel subscribers.
    
    Args:
        message_type: Type of message to send
        data: Message data
        
    Returns:
        int: Number of clients message was sent to
    """
    message = WebSocketMessage(
        id=str(uuid.uuid4()),
        type=message_type,
        channel=Channel.AUTOTRADE,
        data=data,
        timestamp=None  # Will be set automatically
    )
    
    return await ws_hub.broadcast_to_channel(Channel.AUTOTRADE, message)


async def broadcast_discovery_message(message_type: MessageType, data: dict) -> int:
    """
    Broadcast a message to all discovery channel subscribers.
    
    Args:
        message_type: Type of message to send
        data: Message data
        
    Returns:
        int: Number of clients message was sent to
    """
    message = WebSocketMessage(
        id=str(uuid.uuid4()),
        type=message_type,
        channel=Channel.DISCOVERY,
        data=data,
        timestamp=None  # Will be set automatically
    )
    
    return await ws_hub.broadcast_to_channel(Channel.DISCOVERY, message)


async def broadcast_system_message(message_type: MessageType, data: dict) -> int:
    """
    Broadcast a message to all system channel subscribers.
    
    Args:
        message_type: Type of message to send  
        data: Message data
        
    Returns:
        int: Number of clients message was sent to
    """
    message = WebSocketMessage(
        id=str(uuid.uuid4()),
        type=message_type,
        channel=Channel.SYSTEM,
        data=data,
        timestamp=None  # Will be set automatically
    )
    
    return await ws_hub.broadcast_to_channel(Channel.SYSTEM, message)







@router.websocket("/autotrade")
async def websocket_autotrade_endpoint(websocket: WebSocket):
    """Legacy autotrade WebSocket endpoint for frontend compatibility."""
    client_id = f"autotrade_{uuid.uuid4().hex[:8]}"
    logger.info(f"Autotrade WebSocket connection: {client_id}")
    
    # Use existing hub connection logic
    connected = await ws_hub.connect_client(client_id, websocket)
    if not connected:
        return
    
    try:
        while True:
            data = await websocket.receive_text()
            await ws_hub.handle_client_message(client_id, data)
    except WebSocketDisconnect:
        logger.info(f"Autotrade WebSocket disconnected: {client_id}")
    finally:
        await ws_hub.disconnect_client(client_id, "Connection closed")