"""
Pluggable strategy architecture for automated trading with preset management.

This module provides a comprehensive strategy framework supporting multiple
trading strategies with configurable presets, early window management,
and auto-revert logic for safe automated trading operations.
"""
from __future__ import annotations

import asyncio
import time
import uuid
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Dict, List, Optional, Any, Type, Callable
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from enum import Enum

from ..core.logging import get_logger
from ..core.settings import settings
from ..strategy.risk_manager import risk_manager, RiskAssessment, RiskLevel
from ..strategy.safety_controls import safety_controls, CanaryResult
from ..trading.canary import enhanced_canary_tester, CanaryStrategy
from ..discovery.chain_watchers import PairCreatedEvent
from ..ws.discovery_hub import broadcast_trading_opportunity

logger = get_logger(__name__)


class StrategyType(str, Enum):
    """Types of trading strategies."""
    NEW_PAIR_SNIPE = "new_pair_snipe"
    TRENDING_REENTRY = "trending_reentry"
    ARBITRAGE = "arbitrage"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    LIQUIDITY_PROVISION = "liquidity_provision"


class StrategyPreset(str, Enum):
    """Predefined strategy presets."""
    CONSERVATIVE = "conservative"
    STANDARD = "standard"
    AGGRESSIVE = "aggressive"
    CUSTOM = "custom"


class StrategyStatus(str, Enum):
    """Strategy execution status."""
    IDLE = "idle"
    ANALYZING = "analyzing"
    WAITING = "waiting"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    REVERTED = "reverted"


class TriggerCondition(str, Enum):
    """Strategy trigger conditions."""
    IMMEDIATE = "immediate"
    LIQUIDITY_THRESHOLD = "liquidity_threshold"
    BLOCK_DELAY = "block_delay"
    TIME_DELAY = "time_delay"
    VOLUME_SPIKE = "volume_spike"
    PRICE_MOVEMENT = "price_movement"


@dataclass
class StrategyConfig:
    """Base configuration for all strategies."""
    strategy_type: StrategyType
    preset: StrategyPreset
    enabled: bool = True
    max_position_size_usd: Decimal = Decimal("100")
    max_daily_trades: int = 10
    max_slippage_percent: float = 15.0
    min_liquidity_usd: Decimal = Decimal("1000")
    risk_tolerance: RiskLevel = RiskLevel.MEDIUM
    auto_revert_enabled: bool = True
    auto_revert_delay_minutes: int = 5
    position_sizing_method: str = "fixed"  # fixed, percentage, dynamic
    take_profit_percent: Optional[float] = None
    stop_loss_percent: Optional[float] = None
    trailing_stop_enabled: bool = False
    custom_parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategySignal:
    """Trading signal generated by strategy."""
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_type: StrategyType = field(...)
    token_address: str = field(...)
    pair_address: str = field(...)
    chain: str = field(...)
    dex: str = field(...)
    action: str = field(...)  # buy, sell, hold
    confidence: float = field(...)  # 0.0 - 1.0
    recommended_size_usd: Decimal = field(...)
    entry_price: Optional[Decimal] = field(default=None)
    target_price: Optional[Decimal] = field(default=None)
    stop_loss_price: Optional[Decimal] = field(default=None)
    urgency: str = field(default="normal")  # low, normal, high, urgent
    valid_until: datetime = field(default_factory=lambda: datetime.now(timezone.utc) + timedelta(minutes=15))
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class StrategyExecution:
    """Strategy execution tracking."""
    execution_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_type: StrategyType = field(...)
    signal: StrategySignal = field(...)
    status: StrategyStatus = field(default=StrategyStatus.IDLE)
    start_time: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    end_time: Optional[datetime] = field(default=None)
    trades_executed: List[Dict[str, Any]] = field(default_factory=list)
    total_cost_usd: Decimal = field(default=Decimal("0"))
    realized_pnl_usd: Decimal = field(default=Decimal("0"))
    unrealized_pnl_usd: Decimal = field(default=Decimal("0"))
    revert_executed: bool = field(default=False)
    failure_reason: Optional[str] = field(default=None)
    performance_metrics: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Provides common functionality for strategy implementation including
    risk management, position sizing, and execution tracking.
    """
    
    def __init__(self, config: StrategyConfig):
        """Initialize strategy with configuration."""
        self.config = config
        self.strategy_id = str(uuid.uuid4())
        self.executions: Dict[str, StrategyExecution] = {}
        self.performance_stats = {
            "total_signals": 0,
            "successful_trades": 0,
            "failed_trades": 0,
            "total_pnl_usd": Decimal("0"),
            "win_rate": 0.0,
            "average_hold_time_minutes": 0.0
        }
        
        # Strategy-specific callbacks
        self.signal_callbacks: List[Callable] = []
        self.execution_callbacks: List[Callable] = []
        
        logger.info(
            f"Initialized {self.config.strategy_type.value} strategy",
            extra={
                "strategy_id": self.strategy_id,
                "module": "strategies",
                "strategy_type": self.config.strategy_type.value,
                "preset": self.config.preset.value
            }
        )
    
    @abstractmethod
    async def analyze_opportunity(
        self, 
        data: Dict[str, Any], 
        chain_clients: Optional[Dict] = None
    ) -> Optional[StrategySignal]:
        """
        Analyze market data for trading opportunities.
        
        Args:
            data: Market data (pair events, price data, etc.)
            chain_clients: Available chain clients
            
        Returns:
            Trading signal if opportunity found, None otherwise
        """
        pass
    
    @abstractmethod
    async def validate_signal(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> bool:
        """
        Validate a trading signal before execution.
        
        Args:
            signal: Trading signal to validate
            chain_clients: Available chain clients
            
        Returns:
            True if signal is valid for execution
        """
        pass
    
    async def execute_strategy(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> StrategyExecution:
        """
        Execute trading strategy based on signal.
        
        Args:
            signal: Trading signal to execute
            chain_clients: Available chain clients
            
        Returns:
            Strategy execution result
        """
        execution = StrategyExecution(
            strategy_type=self.config.strategy_type,
            signal=signal,
            status=StrategyStatus.ANALYZING
        )
        
        self.executions[execution.execution_id] = execution
        
        logger.info(
            f"Starting strategy execution for {signal.action} on {signal.token_address}",
            extra={
                "execution_id": execution.execution_id,
                "module": "strategies",
                "strategy_type": self.config.strategy_type.value,
                "token_address": signal.token_address,
                "action": signal.action
            }
        )
        
        try:
            # 1. Safety check
            execution.status = StrategyStatus.ANALYZING
            if not await self._safety_check(signal, chain_clients):
                execution.status = StrategyStatus.FAILED
                execution.failure_reason = "Failed safety checks"
                execution.end_time = datetime.now(timezone.utc)
                return execution
            
            # 2. Risk assessment
            risk_assessment = await self._assess_risk(signal, chain_clients)
            if not self._is_risk_acceptable(risk_assessment):
                execution.status = StrategyStatus.FAILED
                execution.failure_reason = f"Risk too high: {risk_assessment.overall_risk.value}"
                execution.end_time = datetime.now(timezone.utc)
                return execution
            
            # 3. Position sizing
            position_size = await self._calculate_position_size(signal, risk_assessment)
            if position_size <= 0:
                execution.status = StrategyStatus.FAILED
                execution.failure_reason = "Invalid position size"
                execution.end_time = datetime.now(timezone.utc)
                return execution
            
            # 4. Execute trades
            execution.status = StrategyStatus.EXECUTING
            await self._execute_trades(execution, position_size, chain_clients)
            
            # 5. Setup auto-revert if enabled
            if self.config.auto_revert_enabled and execution.status == StrategyStatus.COMPLETED:
                await self._schedule_auto_revert(execution)
            
            # 6. Update performance stats
            self._update_performance_stats(execution)
            
            # 7. Notify callbacks
            await self._notify_execution_callbacks(execution)
            
            execution.end_time = datetime.now(timezone.utc)
            
            logger.info(
                f"Strategy execution completed: {execution.status.value}",
                extra={
                    "execution_id": execution.execution_id,
                    "module": "strategies",
                    "status": execution.status.value,
                    "trades_executed": len(execution.trades_executed),
                    "total_cost_usd": str(execution.total_cost_usd)
                }
            )
            
            return execution
            
        except Exception as e:
            execution.status = StrategyStatus.FAILED
            execution.failure_reason = str(e)
            execution.end_time = datetime.now(timezone.utc)
            
            logger.error(
                f"Strategy execution failed: {e}",
                extra={
                    "execution_id": execution.execution_id,
                    "module": "strategies",
                    "error": str(e)
                }
            )
            
            return execution
    
    async def _safety_check(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict]
    ) -> bool:
        """Perform comprehensive safety checks."""
        try:
            is_safe, blocking_reasons = await safety_controls.check_trade_safety(
                token_address=signal.token_address,
                chain=signal.chain,
                trade_amount_usd=signal.recommended_size_usd
            )
            
            if not is_safe:
                logger.warning(
                    f"Safety check failed: {', '.join(blocking_reasons)}",
                    extra={
                        "module": "strategies",
                        "token_address": signal.token_address,
                        "blocking_reasons": blocking_reasons
                    }
                )
            
            return is_safe
            
        except Exception as e:
            logger.error(f"Safety check error: {e}")
            return False  # Fail safe
    
    async def _assess_risk(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict]
    ) -> RiskAssessment:
        """Assess risk for the trading signal."""
        return await risk_manager.assess_token_risk(
            token_address=signal.token_address,
            chain=signal.chain,
            chain_clients=chain_clients or {},
            trade_amount=signal.recommended_size_usd
        )
    
    def _is_risk_acceptable(self, risk_assessment: RiskAssessment) -> bool:
        """Check if risk level is acceptable for strategy."""
        acceptable_levels = {
            RiskLevel.LOW: [RiskLevel.LOW, RiskLevel.MEDIUM, RiskLevel.HIGH],
            RiskLevel.MEDIUM: [RiskLevel.LOW, RiskLevel.MEDIUM],
            RiskLevel.HIGH: [RiskLevel.LOW]
        }
        
        return risk_assessment.overall_risk in acceptable_levels.get(
            self.config.risk_tolerance, [RiskLevel.LOW]
        )
    
    async def _calculate_position_size(
        self, 
        signal: StrategySignal, 
        risk_assessment: RiskAssessment
    ) -> Decimal:
        """Calculate appropriate position size."""
        base_size = signal.recommended_size_usd
        
        # Apply risk-based scaling
        risk_multiplier = {
            RiskLevel.LOW: Decimal("1.0"),
            RiskLevel.MEDIUM: Decimal("0.7"),
            RiskLevel.HIGH: Decimal("0.4"),
            RiskLevel.CRITICAL: Decimal("0.1")
        }.get(risk_assessment.overall_risk, Decimal("0.1"))
        
        # Apply confidence scaling
        confidence_multiplier = Decimal(str(signal.confidence))
        
        # Calculate final size
        position_size = base_size * risk_multiplier * confidence_multiplier
        
        # Apply maximum limits
        position_size = min(position_size, self.config.max_position_size_usd)
        
        return position_size
    
    async def _execute_trades(
        self, 
        execution: StrategyExecution, 
        position_size: Decimal, 
        chain_clients: Optional[Dict]
    ) -> None:
        """Execute the actual trades for the strategy."""
        # This would integrate with the trade executor
        # For now, simulate trade execution
        
        signal = execution.signal
        
        if signal.action == "buy":
            # Simulate buy execution
            trade_result = {
                "trade_id": str(uuid.uuid4()),
                "action": "buy",
                "token_address": signal.token_address,
                "amount_usd": position_size,
                "price": signal.entry_price,
                "tx_hash": f"0x{'a' * 64}",  # Simulated
                "gas_used": 150000,
                "timestamp": datetime.now(timezone.utc)
            }
            
            execution.trades_executed.append(trade_result)
            execution.total_cost_usd += position_size
            execution.status = StrategyStatus.COMPLETED
            
        elif signal.action == "sell":
            # Simulate sell execution
            trade_result = {
                "trade_id": str(uuid.uuid4()),
                "action": "sell",
                "token_address": signal.token_address,
                "amount_usd": position_size,
                "price": signal.entry_price,
                "tx_hash": f"0x{'b' * 64}",  # Simulated
                "gas_used": 120000,
                "timestamp": datetime.now(timezone.utc)
            }
            
            execution.trades_executed.append(trade_result)
            execution.realized_pnl_usd += position_size * Decimal("0.02")  # Simulate 2% profit
            execution.status = StrategyStatus.COMPLETED
    
    async def _schedule_auto_revert(self, execution: StrategyExecution) -> None:
        """Schedule automatic revert for the execution."""
        if not execution.trades_executed:
            return
        
        # Schedule revert after delay
        revert_time = datetime.now(timezone.utc) + timedelta(
            minutes=self.config.auto_revert_delay_minutes
        )
        
        # This would integrate with a job scheduler
        logger.info(
            f"Auto-revert scheduled for {revert_time.isoformat()}",
            extra={
                "execution_id": execution.execution_id,
                "module": "strategies",
                "revert_time": revert_time.isoformat()
            }
        )
    
    def _update_performance_stats(self, execution: StrategyExecution) -> None:
        """Update strategy performance statistics."""
        self.performance_stats["total_signals"] += 1
        
        if execution.status == StrategyStatus.COMPLETED:
            self.performance_stats["successful_trades"] += 1
            self.performance_stats["total_pnl_usd"] += execution.realized_pnl_usd
        else:
            self.performance_stats["failed_trades"] += 1
        
        # Calculate win rate
        total_trades = (
            self.performance_stats["successful_trades"] + 
            self.performance_stats["failed_trades"]
        )
        if total_trades > 0:
            self.performance_stats["win_rate"] = (
                self.performance_stats["successful_trades"] / total_trades * 100
            )
    
    async def _notify_execution_callbacks(self, execution: StrategyExecution) -> None:
        """Notify registered callbacks about execution."""
        for callback in self.execution_callbacks:
            try:
                await callback(execution)
            except Exception as e:
                logger.error(f"Execution callback error: {e}")
    
    def add_signal_callback(self, callback: Callable) -> None:
        """Add callback for signal generation."""
        self.signal_callbacks.append(callback)
    
    def add_execution_callback(self, callback: Callable) -> None:
        """Add callback for execution completion."""
        self.execution_callbacks.append(callback)
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Get strategy performance statistics."""
        return {
            "strategy_id": self.strategy_id,
            "strategy_type": self.config.strategy_type.value,
            "preset": self.config.preset.value,
            "enabled": self.config.enabled,
            "total_executions": len(self.executions),
            "active_executions": len([
                ex for ex in self.executions.values() 
                if ex.status in [StrategyStatus.ANALYZING, StrategyStatus.EXECUTING]
            ]),
            **self.performance_stats
        }


class NewPairSnipeStrategy(BaseStrategy):
    """
    Strategy for sniping newly created trading pairs.
    
    Monitors for new pair creation events and attempts to enter
    positions within specified block windows for early entry advantage.
    """
    
    def __init__(self, config: StrategyConfig):
        """Initialize new pair snipe strategy."""
        super().__init__(config)
        self.monitored_chains = config.custom_parameters.get(
            "monitored_chains", ["ethereum", "bsc", "polygon"]
        )
        self.max_block_delay = config.custom_parameters.get("max_block_delay", 5)
        self.require_canary_test = config.custom_parameters.get("require_canary_test", True)
    
    async def analyze_opportunity(
        self, 
        data: Dict[str, Any], 
        chain_clients: Optional[Dict] = None
    ) -> Optional[StrategySignal]:
        """Analyze new pair creation for sniping opportunity."""
        if not isinstance(data.get("event"), PairCreatedEvent):
            return None
        
        event: PairCreatedEvent = data["event"]
        
        # Check if chain is monitored
        if event.chain not in self.monitored_chains:
            return None
        
        # Check block timing
        current_block = data.get("current_block", 0)
        if current_block - event.block_number > self.max_block_delay:
            logger.debug(f"Pair too old: {current_block - event.block_number} blocks")
            return None
        
        # Determine target token (non-native token)
        native_tokens = {
            "ethereum": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
            "bsc": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
            "polygon": "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"
        }
        
        native_token = native_tokens.get(event.chain, "").lower()
        target_token = event.token0 if event.token1.lower() == native_token else event.token1
        
        # Calculate confidence based on timing and liquidity
        block_delay_factor = max(0, 1 - (current_block - event.block_number) / self.max_block_delay)
        base_confidence = 0.7 + (block_delay_factor * 0.3)
        
        # Create trading signal
        signal = StrategySignal(
            strategy_type=StrategyType.NEW_PAIR_SNIPE,
            token_address=target_token,
            pair_address=event.pair_address,
            chain=event.chain,
            dex=event.dex,
            action="buy",
            confidence=base_confidence,
            recommended_size_usd=self.config.max_position_size_usd * Decimal("0.1"),  # Start with 10%
            urgency="high",
            metadata={
                "block_number": event.block_number,
                "block_delay": current_block - event.block_number,
                "native_token": native_token,
                "requires_canary": self.require_canary_test
            }
        )
        
        logger.info(
            f"New pair snipe opportunity: {target_token} on {event.chain}",
            extra={
                "signal_id": signal.signal_id,
                "module": "strategies",
                "token_address": target_token,
                "confidence": signal.confidence,
                "block_delay": current_block - event.block_number
            }
        )
        
        return signal
    
    async def validate_signal(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> bool:
        """Validate new pair snipe signal."""
        try:
            # Check if canary test is required and execute it
            if signal.metadata.get("requires_canary", False):
                canary_result = await enhanced_canary_tester.execute_canary_test(
                    token_address=signal.token_address,
                    chain=signal.chain,
                    strategy=CanaryStrategy.INSTANT,
                    chain_clients=chain_clients
                )
                
                if not canary_result.outcome.value == "success":
                    logger.warning(
                        f"Canary test failed: {canary_result.outcome.value}",
                        extra={
                            "signal_id": signal.signal_id,
                            "module": "strategies",
                            "canary_outcome": canary_result.outcome.value
                        }
                    )
                    return False
            
            # Additional validation checks
            # Check if signal is still valid (not expired)
            if datetime.now(timezone.utc) > signal.valid_until:
                return False
            
            # Check block timing hasn't degraded too much
            current_block = signal.metadata.get("current_block", 0)
            block_delay = current_block - signal.metadata.get("block_number", 0)
            if block_delay > self.max_block_delay * 2:  # Double the original limit
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Signal validation error: {e}")
            return False


class TrendingReentryStrategy(BaseStrategy):
    """
    Strategy for re-entering trending tokens with momentum.
    
    Monitors tokens for volume/price momentum and attempts
    re-entry on established trends with proper risk management.
    """
    
    def __init__(self, config: StrategyConfig):
        """Initialize trending re-entry strategy."""
        super().__init__(config)
        self.min_volume_24h = config.custom_parameters.get("min_volume_24h", 50000)
        self.min_price_change_percent = config.custom_parameters.get("min_price_change_percent", 10)
        self.lookback_hours = config.custom_parameters.get("lookback_hours", 24)
    
    async def analyze_opportunity(
        self, 
        data: Dict[str, Any], 
        chain_clients: Optional[Dict] = None
    ) -> Optional[StrategySignal]:
        """Analyze market data for trending re-entry opportunities."""
        # This would analyze price/volume data for trending opportunities
        # For now, return None as this requires market data integration
        return None
    
    async def validate_signal(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> bool:
        """Validate trending re-entry signal."""
        # Validate momentum and volume conditions
        return True


class StrategyManager:
    """
    Manager for all trading strategies with preset support.
    
    Coordinates multiple strategies, manages their lifecycle,
    and provides unified interface for strategy operations.
    """
    
    def __init__(self):
        """Initialize strategy manager."""
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_executions: Dict[str, StrategyExecution] = {}
        
        # Performance tracking
        self.total_signals_generated = 0
        self.total_executions = 0
        self.successful_executions = 0
        
        logger.info("Strategy manager initialized")
    
    def register_strategy(self, strategy: BaseStrategy) -> None:
        """Register a strategy with the manager."""
        self.strategies[strategy.strategy_id] = strategy
        
        # Add callbacks for tracking
        strategy.add_execution_callback(self._on_execution_complete)
        
        logger.info(
            f"Registered strategy: {strategy.config.strategy_type.value}",
            extra={
                "strategy_id": strategy.strategy_id,
                "module": "strategies",
                "strategy_type": strategy.config.strategy_type.value
            }
        )
    
    def create_strategy_from_preset(
        self, 
        strategy_type: StrategyType, 
        preset: StrategyPreset,
        custom_params: Optional[Dict[str, Any]] = None
    ) -> BaseStrategy:
        """Create strategy instance from preset configuration."""
        config = self._get_preset_config(strategy_type, preset, custom_params)
        
        if strategy_type == StrategyType.NEW_PAIR_SNIPE:
            return NewPairSnipeStrategy(config)
        elif strategy_type == StrategyType.TRENDING_REENTRY:
            return TrendingReentryStrategy(config)
        else:
            raise ValueError(f"Unsupported strategy type: {strategy_type}")
    
    def _get_preset_config(
        self, 
        strategy_type: StrategyType, 
        preset: StrategyPreset,
        custom_params: Optional[Dict[str, Any]]
    ) -> StrategyConfig:
        """Get configuration for strategy preset."""
        base_configs = {
            StrategyPreset.CONSERVATIVE: {
                "max_position_size_usd": Decimal("50"),
                "max_slippage_percent": 10.0,
                "min_liquidity_usd": Decimal("5000"),
                "risk_tolerance": RiskLevel.LOW,
                "auto_revert_enabled": True,
                "auto_revert_delay_minutes": 3
            },
            StrategyPreset.STANDARD: {
                "max_position_size_usd": Decimal("100"),
                "max_slippage_percent": 15.0,
                "min_liquidity_usd": Decimal("2000"),
                "risk_tolerance": RiskLevel.MEDIUM,
                "auto_revert_enabled": True,
                "auto_revert_delay_minutes": 5
            },
            StrategyPreset.AGGRESSIVE: {
                "max_position_size_usd": Decimal("250"),
                "max_slippage_percent": 25.0,
                "min_liquidity_usd": Decimal("1000"),
                "risk_tolerance": RiskLevel.HIGH,
                "auto_revert_enabled": False,
                "auto_revert_delay_minutes": 10
            }
        }
        
        config_params = base_configs.get(preset, base_configs[StrategyPreset.STANDARD])
        
        if custom_params:
            config_params.update(custom_params)
        
        return StrategyConfig(
            strategy_type=strategy_type,
            preset=preset,
            **config_params
        )
    
    async def process_market_data(
        self, 
        data: Dict[str, Any], 
        chain_clients: Optional[Dict] = None
    ) -> List[StrategySignal]:
        """Process market data through all active strategies."""
        signals = []
        
        for strategy in self.strategies.values():
            if not strategy.config.enabled:
                continue
            
            try:
                signal = await strategy.analyze_opportunity(data, chain_clients)
                if signal:
                    self.total_signals_generated += 1
                    signals.append(signal)
                    
                    # Broadcast trading opportunity
                    await broadcast_trading_opportunity(
                        chain=signal.chain,
                        pair_address=signal.pair_address,
                        token0=signal.token_address,
                        token1=signal.metadata.get("native_token", ""),
                        dex=signal.dex,
                        opportunity_type=signal.strategy_type.value,
                        metadata={
                            "confidence": signal.confidence,
                            "recommended_size_usd": str(signal.recommended_size_usd),
                            "urgency": signal.urgency
                        }
                    )
                    
            except Exception as e:
                logger.error(f"Strategy analysis error: {e}")
        
        return signals
    
    async def execute_signal(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> Optional[StrategyExecution]:
        """Execute a trading signal through appropriate strategy."""
        strategy = self._find_strategy_for_signal(signal)
        if not strategy:
            logger.warning(f"No strategy found for signal: {signal.signal_id}")
            return None
        
        # Validate signal first
        if not await strategy.validate_signal(signal, chain_clients):
            logger.warning(f"Signal validation failed: {signal.signal_id}")
            return None
        
        # Execute strategy
        execution = await strategy.execute_strategy(signal, chain_clients)
        self.active_executions[execution.execution_id] = execution
        self.total_executions += 1
        
        return execution
    
    def _find_strategy_for_signal(self, signal: StrategySignal) -> Optional[BaseStrategy]:
        """Find appropriate strategy for executing a signal."""
        for strategy in self.strategies.values():
            if (strategy.config.strategy_type == signal.strategy_type and 
                strategy.config.enabled):
                return strategy
        return None
    
    async def _on_execution_complete(self, execution: StrategyExecution) -> None:
        """Handle strategy execution completion."""
        if execution.status == StrategyStatus.COMPLETED:
            self.successful_executions += 1
        
        # Clean up completed executions
        if execution.execution_id in self.active_executions:
            del self.active_executions[execution.execution_id]
    
    def get_manager_stats(self) -> Dict[str, Any]:
        """Get strategy manager statistics."""
        success_rate = 0.0
        if self.total_executions > 0:
            success_rate = (self.successful_executions / self.total_executions) * 100
        
        return {
            "total_strategies": len(self.strategies),
            "active_strategies": len([s for s in self.strategies.values() if s.config.enabled]),
            "total_signals_generated": self.total_signals_generated,
            "total_executions": self.total_executions,
            "successful_executions": self.successful_executions,
            "success_rate": success_rate,
            "active_executions": len(self.active_executions),
            "strategy_performance": {
                strategy_id: strategy.get_performance_stats()
                for strategy_id, strategy in self.strategies.items()
            }
        }


# Global strategy manager instance
strategy_manager = StrategyManager()