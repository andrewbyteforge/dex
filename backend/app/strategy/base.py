"""
Base strategy framework with lifecycle management for automated trading.

This module provides the core strategy architecture supporting multiple
trading strategies with configurable presets, signal generation,
and execution lifecycle management.
"""
from __future__ import annotations

import asyncio
import time
import uuid
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Dict, List, Optional, Any, Type, Callable, Union
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from enum import Enum

from ..core.logging import get_logger
from ..strategy.risk_manager import RiskLevel, RiskAssessment

logger = get_logger(__name__)


class StrategyType(str, Enum):
    """Types of trading strategies."""
    NEW_PAIR_SNIPE = "new_pair_snipe"
    TRENDING_REENTRY = "trending_reentry"
    ARBITRAGE = "arbitrage"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    LIQUIDITY_PROVISION = "liquidity_provision"


class StrategyPreset(str, Enum):
    """Predefined strategy presets."""
    CONSERVATIVE = "conservative"
    STANDARD = "standard"
    AGGRESSIVE = "aggressive"
    CUSTOM = "custom"


class StrategyStatus(str, Enum):
    """Strategy execution status."""
    IDLE = "idle"
    ANALYZING = "analyzing"
    WAITING = "waiting"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    REVERTED = "reverted"


class SignalType(str, Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT = "exit"


class TriggerCondition(str, Enum):
    """Strategy trigger conditions."""
    IMMEDIATE = "immediate"
    LIQUIDITY_THRESHOLD = "liquidity_threshold"
    BLOCK_DELAY = "block_delay"
    TIME_DELAY = "time_delay"
    VOLUME_SPIKE = "volume_spike"
    PRICE_MOVEMENT = "price_movement"


@dataclass
class StrategyConfig:
    """Base configuration for all strategies."""
    strategy_type: StrategyType
    preset: StrategyPreset
    enabled: bool = True
    max_position_size_usd: Decimal = Decimal("100")
    max_daily_trades: int = 10
    max_slippage_percent: float = 15.0
    min_liquidity_usd: Decimal = Decimal("1000")
    risk_tolerance: RiskLevel = RiskLevel.MEDIUM
    auto_revert_enabled: bool = True
    auto_revert_delay_minutes: int = 5
    position_sizing_method: str = "fixed"  # fixed, percentage, dynamic
    take_profit_percent: Optional[float] = None
    stop_loss_percent: Optional[float] = None
    trailing_stop_enabled: bool = False
    trigger_conditions: List[TriggerCondition] = field(default_factory=lambda: [TriggerCondition.IMMEDIATE])
    custom_parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategySignal:
    """Trading signal generated by strategy."""
    signal_id: str
    strategy_id: str
    signal_type: SignalType
    chain: str
    token_address: str
    pair_address: str
    confidence: float  # 0.0 to 1.0
    expected_return_percent: Optional[float]
    position_size_usd: Decimal
    max_slippage_percent: float
    timestamp: datetime
    valid_until: Optional[datetime]
    trigger_conditions: List[TriggerCondition]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_valid(self) -> bool:
        """Check if signal is still valid."""
        if self.valid_until and datetime.now(timezone.utc) > self.valid_until:
            return False
        return True


@dataclass
class StrategyExecution:
    """Represents an active strategy execution."""
    execution_id: str
    strategy_id: str
    signal: StrategySignal
    status: StrategyStatus
    start_time: datetime
    end_time: Optional[datetime] = None
    result: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    trace_id: Optional[str] = None
    revert_scheduled: bool = False
    revert_time: Optional[datetime] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Provides the common interface and lifecycle management
    for strategy implementations.
    """
    
    def __init__(self, config: StrategyConfig):
        """Initialize strategy with configuration."""
        self.config = config
        self.strategy_id = f"{config.strategy_type.value}_{uuid.uuid4().hex[:8]}"
        self.status = StrategyStatus.IDLE
        self.created_at = datetime.now(timezone.utc)
        self.last_execution: Optional[datetime] = None
        
        # Performance tracking
        self.total_signals = 0
        self.successful_executions = 0
        self.failed_executions = 0
        self.total_pnl = Decimal("0")
        
        # Callbacks for lifecycle events
        self._signal_callbacks: List[Callable] = []
        self._execution_callbacks: List[Callable] = []
        
        logger.info(
            f"Strategy initialized: {self.config.strategy_type.value}",
            extra={
                "strategy_id": self.strategy_id,
                "module": "strategy_base",
                "strategy_type": self.config.strategy_type.value,
                "preset": self.config.preset.value
            }
        )
    
    @abstractmethod
    async def generate_signals(
        self, 
        market_data: Dict[str, Any], 
        chain_clients: Optional[Dict] = None
    ) -> List[StrategySignal]:
        """
        Generate trading signals based on market data.
        
        Args:
            market_data: Current market data and events
            chain_clients: Optional chain client instances
            
        Returns:
            List of trading signals
            
        Raises:
            StrategyError: If signal generation fails
        """
        pass
    
    @abstractmethod
    async def validate_signal(
        self, 
        signal: StrategySignal, 
        chain_clients: Optional[Dict] = None
    ) -> bool:
        """
        Validate if a signal should be executed.
        
        Args:
            signal: Signal to validate
            chain_clients: Optional chain client instances
            
        Returns:
            True if signal is valid for execution
            
        Raises:
            StrategyError: If validation fails
        """
        pass
    
    async def should_execute(self, current_time: Optional[datetime] = None) -> bool:
        """
        Check if strategy should attempt execution.
        
        Args:
            current_time: Current time for testing
            
        Returns:
            True if strategy can execute
        """
        if not self.config.enabled:
            return False
        
        if self.status not in [StrategyStatus.IDLE, StrategyStatus.WAITING]:
            return False
        
        # Check daily trade limits
        if self.last_execution:
            time_since_last = (current_time or datetime.now(timezone.utc)) - self.last_execution
            if time_since_last < timedelta(hours=24) / self.config.max_daily_trades:
                return False
        
        return True
    
    def calculate_position_size(
        self, 
        signal: StrategySignal,
        available_balance: Decimal,
        risk_assessment: Optional[RiskAssessment] = None
    ) -> Decimal:
        """
        Calculate position size based on strategy configuration.
        
        Args:
            signal: Trading signal
            available_balance: Available balance for trading
            risk_assessment: Optional risk assessment
            
        Returns:
            Position size in USD
        """
        if self.config.position_sizing_method == "fixed":
            return min(self.config.max_position_size_usd, available_balance)
        
        elif self.config.position_sizing_method == "percentage":
            # Use 10% of available balance by default
            percentage = self.config.custom_parameters.get("balance_percentage", 0.1)
            calculated_size = available_balance * Decimal(str(percentage))
            return min(calculated_size, self.config.max_position_size_usd)
        
        elif self.config.position_sizing_method == "dynamic":
            # Adjust based on confidence and risk
            base_size = self.config.max_position_size_usd
            confidence_multiplier = Decimal(str(signal.confidence))
            
            if risk_assessment:
                risk_multiplier = {
                    RiskLevel.VERY_LOW: Decimal("1.2"),
                    RiskLevel.LOW: Decimal("1.0"),
                    RiskLevel.MEDIUM: Decimal("0.8"),
                    RiskLevel.HIGH: Decimal("0.6"),
                    RiskLevel.VERY_HIGH: Decimal("0.3")
                }.get(risk_assessment.overall_risk, Decimal("0.5"))
            else:
                risk_multiplier = Decimal("1.0")
            
            calculated_size = base_size * confidence_multiplier * risk_multiplier
            return min(calculated_size, available_balance)
        
        return self.config.max_position_size_usd
    
    def add_signal_callback(self, callback: Callable[[StrategySignal], None]) -> None:
        """Add callback for signal generation events."""
        self._signal_callbacks.append(callback)
    
    def add_execution_callback(self, callback: Callable[[StrategyExecution], None]) -> None:
        """Add callback for execution completion events."""
        self._execution_callbacks.append(callback)
    
    def _emit_signal(self, signal: StrategySignal) -> None:
        """Emit signal to registered callbacks."""
        self.total_signals += 1
        for callback in self._signal_callbacks:
            try:
                callback(signal)
            except Exception as e:
                logger.error(
                    f"Signal callback failed: {e}",
                    extra={
                        "strategy_id": self.strategy_id,
                        "signal_id": signal.signal_id,
                        "module": "strategy_base"
                    }
                )
    
    def _emit_execution_complete(self, execution: StrategyExecution) -> None:
        """Emit execution completion to registered callbacks."""
        if execution.status == StrategyStatus.COMPLETED:
            self.successful_executions += 1
        elif execution.status == StrategyStatus.FAILED:
            self.failed_executions += 1
        
        for callback in self._execution_callbacks:
            try:
                callback(execution)
            except Exception as e:
                logger.error(
                    f"Execution callback failed: {e}",
                    extra={
                        "strategy_id": self.strategy_id,
                        "execution_id": execution.execution_id,
                        "module": "strategy_base"
                    }
                )
    
    def get_performance_metrics(self) -> Dict[str, Union[int, float, str]]:
        """Get strategy performance metrics."""
        success_rate = (
            self.successful_executions / max(1, self.successful_executions + self.failed_executions)
        ) * 100
        
        return {
            "strategy_id": self.strategy_id,
            "strategy_type": self.config.strategy_type.value,
            "preset": self.config.preset.value,
            "total_signals": self.total_signals,
            "successful_executions": self.successful_executions,
            "failed_executions": self.failed_executions,
            "success_rate_percent": round(success_rate, 2),
            "total_pnl_usd": float(self.total_pnl),
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "last_execution": self.last_execution.isoformat() if self.last_execution else None
        }


class StrategyError(Exception):
    """Base exception for strategy-related errors."""
    pass


class StrategyConfigError(StrategyError):
    """Raised when strategy configuration is invalid."""
    pass


class StrategyExecutionError(StrategyError):
    """Raised when strategy execution fails."""
    pass